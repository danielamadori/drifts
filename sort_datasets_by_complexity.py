#!/usr/bin/env python3
"""Sort datasets by forest complexity and series length.

This script reads the JSON report generated by ``dataset_forest_report.py`` and
orders the entries by the size of the optimised Random Forest. The forest size
is approximated as the product between the number of estimators and the average
number of nodes per tree. When multiple datasets share the same forest
complexity, the series length is used as a secondary criterion.

Example usage::

    python sort_datasets_by_complexity.py --report results/forest_report.json

By default datasets are printed from the most complex to the simplest. Use
``--ascending`` to reverse the order.
"""

from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Mapping, Sequence


@dataclass
class DatasetComplexity:
    """Data container for the complexity metrics of a dataset."""

    dataset: str
    forest_dimension: float
    series_length: int


def _load_report(path: Path) -> Sequence[Mapping[str, object]]:
    """Load the dataset report stored as JSON."""

    try:
        with path.open("r", encoding="utf-8") as handle:
            payload = json.load(handle)
    except FileNotFoundError as exc:  # pragma: no cover - runtime behaviour
        raise SystemExit(f"Unable to read report: {path} not found") from exc
    except json.JSONDecodeError as exc:  # pragma: no cover - runtime behaviour
        raise SystemExit(f"Unable to parse JSON report at {path}: {exc}") from exc

    if not isinstance(payload, list):
        raise SystemExit(
            "The JSON report is expected to contain a list of dataset entries."
        )

    return payload


def _compute_forest_dimension(statistics: Mapping[str, object] | None) -> float:
    """Return an approximate measure of the forest size."""

    if not isinstance(statistics, Mapping):
        return 0.0

    n_estimators = statistics.get("n_estimators")
    avg_nodes = statistics.get("avg_nodes")

    try:
        n_estimators_value = float(n_estimators)
        avg_nodes_value = float(avg_nodes)
    except (TypeError, ValueError):
        return 0.0

    return n_estimators_value * avg_nodes_value


def _extract_series_length(metadata: Mapping[str, object] | None) -> int:
    """Extract the series length recorded in the dataset metadata."""

    if not isinstance(metadata, Mapping):
        return 0

    length = metadata.get("series_length")
    try:
        return int(length)
    except (TypeError, ValueError):
        return 0


def _summarise_datasets(report: Sequence[Mapping[str, object]]) -> List[DatasetComplexity]:
    """Collect the complexity metrics for every dataset in the report."""

    summaries: List[DatasetComplexity] = []

    for entry in report:
        if not isinstance(entry, Mapping):
            continue

        dataset = str(entry.get("dataset", "")) or "<unknown>"
        statistics = entry.get("forest_statistics")
        metadata = entry.get("metadata")

        forest_dimension = _compute_forest_dimension(
            statistics if isinstance(statistics, Mapping) else None
        )
        series_length = _extract_series_length(
            metadata if isinstance(metadata, Mapping) else None
        )

        summaries.append(
            DatasetComplexity(
                dataset=dataset,
                forest_dimension=forest_dimension,
                series_length=series_length,
            )
        )

    return summaries


def _sort_datasets(
    datasets: Iterable[DatasetComplexity], *, ascending: bool
) -> List[DatasetComplexity]:
    """Sort datasets by forest dimension and series length."""

    def _key(item: DatasetComplexity) -> tuple[float, int, str]:
        dimension = item.forest_dimension
        length = item.series_length

        if ascending:
            return (dimension, length, item.dataset)

        # Negative values invert the ordering without reversing the dataset name.
        return (-dimension, -length, item.dataset)

    return sorted(datasets, key=_key)


def _format_dimension(value: float) -> str:
    """Format the forest dimension for display."""

    if value == 0:
        return "0"
    return f"{value:,.2f}"


def _print_table(datasets: Sequence[DatasetComplexity]) -> None:
    """Display the sorted datasets as a simple table."""

    name_width = max((len(item.dataset) for item in datasets), default=6)

    header_dataset = "Dataset".ljust(name_width)
    header_dimension = "Forest dimension"
    header_length = "Series length"

    print(f"{header_dataset}  {header_dimension:>17}  {header_length:>13}")
    print(f"{'-' * name_width}  {'-' * 17:>17}  {'-' * 13:>13}")

    for item in datasets:
        dataset = item.dataset.ljust(name_width)
        dimension = _format_dimension(item.forest_dimension).rjust(17)
        length = f"{item.series_length}".rjust(13)
        print(f"{dataset}  {dimension}  {length}")


def _parse_args() -> argparse.Namespace:
    """Collect command line arguments."""

    parser = argparse.ArgumentParser(
        description=(
            "Sort datasets by the complexity of their optimised Random Forest "
            "and series length."
        )
    )
    parser.add_argument(
        "--report",
        type=Path,
        default=Path("forest_report.json"),
        help="Path to the JSON report generated by dataset_forest_report.py.",
    )
    parser.add_argument(
        "--ascending",
        action="store_true",
        help="Print datasets from the simplest (smallest forest) to the most complex.",
    )
    parser.add_argument(
        "--limit",
        type=int,
        default=None,
        help="Restrict the output to the first N datasets after sorting.",
    )

    return parser.parse_args()


def main() -> None:
    """Entrypoint for the command line interface."""

    args = _parse_args()
    report = _load_report(args.report)
    summaries = _summarise_datasets(report)
    ordered = _sort_datasets(summaries, ascending=args.ascending)

    if args.limit is not None:
        ordered = ordered[: args.limit]

    _print_table(ordered)


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    main()
